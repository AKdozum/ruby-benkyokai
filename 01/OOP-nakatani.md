# アジェンダ

1. 書ける! Rubyコード! [15分くらい]
1. オブジェクト指向プログラミング(OOP) [30分くらい]


# 書ける! Rubyコード!

## インストール

`ruby`コマンドと`irb`コマンドを実行できるようにしておいてください。
自走できるエンジニアなら自分でできるはず・・・

`irb`は対話的なインタプリタ。Perlでいうところの`reply`みたいなもの。

バージョンは特に指定しませんが、自分が勉強会資料に書くサンプルコードは2.0.0で動作確認します。

## Hello, world!

何はなくともHello, world!

`hello.rb`
```ruby
puts 'Hello, world!'
```

実行します。

```bash
$ ruby src/hello.rb
Hello, world
```

## irb

「この文法で合ってるっけ??」などのちょっとした確認は、
いちいちソースファイルを保存して実行するのが煩わしいこともありますね。

そんな時に`irb`。

```bash
$ irb
irb(main):001:0> puts "Hello, world!"
Hello, world!
=> nil
```

電卓代わりによく使ってます。大きい整数も難なく扱えるし便利です。

```bash
$ irb
irb(main):001:0> 1 + 1
=> 2
irb(main):002:0> 10000000000000000000000000000000000000 * 7
=> 70000000000000000000000000000000000000
```

## ri

意識の高いエンジニアなら、「`puts`って? 関数? どんな関数?」と思ったはず。

そんなあなたに`ri`。`perldoc`相当です。

```bash
$ ri puts
= .puts

(from ruby core)
=== Implementation from ARGF
------------------------------------------------------------------------------
  ios.puts(obj, ...)    -> nil

------------------------------------------------------------------------------

...
```


## Rubyのデータ型

ごく単純なプログラムを書く上でもお世話になる、基本的なデータ型をまとめます。

- 数値
- 文字列
- 配列
- シンボル
- ハッシュ

### (脱線) リテラル

これらのデータ型には全て**リテラル**があります。
リテラルというのは、プログラム中に直接書けるデータ型の記述のことです。

例: Perlにはハッシュのリテラルがあるけど、、、
```perl
{
    DeNA    => 'Perl',
    CookPad => 'Ruby',
}
```

例: Javaにはハッシュのリテラルがない
```java
HashMap<String,String> lang = new HashMap<String, String>();
lang.put("DeNA"    , "Perl");
lang.put("CookPad" , "Ruby");
```

なお、リテラルとネイティブ型は同列に語られることもちらほらありますが、独立概念です。
現に、上記に挙げたリテラルのあるデータ型は、全てネイティブ型ではありません。
これは後の項目で話します。

また、上記に挙げた以外にもリテラルを持つデータ型はあります(正規表現リテラルなど)が、今回は触れません。

脱線しましたが、各種のデータ型を見ていきます。


### 数値

思いつくのは何でも使える感じです。

```ruby
# 10進整数
1000
-777
123_456_789_123_456_789_123_456_789  # アンダースコアは無視される。Perlと同様

# 浮動小数
3.14
3.0e8  # 指数表記
1.6e-19

# 16進数
0xFFA
-0xabc

# 2進数
0b0110

# 8進数
0177
0o177
```

### 文字列

基本的に、シングルクオートかダブルクオートで括れば文字列になります。

```ruby
irb(main):009:0> 'hello'
=> "hello"
irb(main):010:0> "world"
=> "world"
```

ダブルクオートの場合は**式展開**が使えます。
Perlでもダブルクオートだと変数展開してくれますが、Rubyの式展開のほうが色々出来ますね。

```ruby
irb(main):011:0> "1 + 1 = #{1 + 1}"
=> "1 + 1 = 2"
irb(main):012:0> '1 + 1 = #{1 + 1}'
=> "1 + 1 = \#{1 + 1}"
irb(main):013:0> v = 1    # 未出ですが、変数宣言です
=> 1
irb(main):014:0> "1 + 1 = #{v + v}"
=> "1 + 1 = 2"
```

また、ダブルクオートでは**バックスラッシュ記法**も利用できます。

```ruby
irb(main):019:0> puts "happy\tcoding\n"
happy   coding
=> nil
irb(main):020:0> puts 'happy\tcoding\n'
happy\tcoding\n
=> nil
```

複数行に渡る文字列を使用する場合は、**ヒアドキュメント**が便利です。

`here_doc.rb`
```ruby
puts "-- Here document --"
puts <<EOS
Hello\tworld!
#{1 + 1}
EOS
```

式展開やバックスラッシュ記法を無効にしたいときは、ヒアドキュメントの識別子(今回はEOS)をシングルクオートで囲みます。

```ruby
puts "-- Single-quoted here document --"
puts <<'EOS'
Hello\tworld!
#{1 + 1}
EOS
```

### 配列

配列の作成は`[]`リテラルによって行います。異なる型を混在して要素に持てることにも着目してください。

```ruby
irb(main):021:0> a = ['a', 'b', 777]
=> ["a", "b", 777]
```

添字による操作などが可能です。

```ruby
irb(main):022:0> a[1]
=> "b"
irb(main):023:0> a[-1]
=> 777
irb(main):024:0> a[3]
=> nil
```

その他にも配列に対する操作はたくさんありますが、今回は割愛します。

配列の作成には、**%記法**を用いることも出来ます。Perlの`qw()`相当です。

```ruby
irb(main):027:0> b = %w(a b 777)
=> ["a", "b", "777"]
irb(main):028:0> b[1]
=> "b"
```


### シンボル

コロンから始めてbare-wordを書くと、シンボルを作成できます。

```ruby
irb(main):029:0> :this_is_a_symbol
=> :this_is_a_symbol
```

シンボルは可読性の高い識別子として有用です。

```ruby
irb(main):032:0> ll = [:python, :ruby, :perl]
=> [:python, :ruby, :perl]
irb(main):033:0> ll[1] == :ruby
=> true
```

シンボルは文字列とは何の関係も持たないので注意してください。

```ruby
irb(main):030:0> 'this_is_a_symbol' == 'this_is_a_symbol'
=> true
irb(main):031:0> :this_is_a_symbol == 'this_is_a_symbol'
=> false
```

### ハッシュ

key/valueのペアであるハッシュは、`{}`リテラルで作成できます。

```ruby
irb(main):036:0> h = {'key1' => 'val1', :key2 => 'val2', 3 => 'val3'}
=> {"key1"=>"val1", :key2=>"val2", 3=>"val3"}
```

キーには文字列もシンボルも数値も使用できることに注目してください。

Ruby 1.9以降では、新しいリテラルが追加されました。
キーをシンボルとする場合はシンタックスシュガーでより簡潔に記述できます。

```ruby
irb(main):037:0> {key1: 'val1', key2: 'val2'}
=> {:key1=>"val1", :key2=>"val2"}
```

また、文法上ハッシュリテラルであることが明らかな箇所では、`{}`を省略することも可能です。

```ruby
irb(main):040:0> puts key1: 'val1', key2: 'val2'
{:key1=>"val1", :key2=>"val2"}
```

(個人的にはすごく可読性を損ねると思うのですが、)実際のコードでもよく省略されています。


## `p`

データ構造をデバッグ用に出力するとき、`p`関数をよく用います。Perlの`Data::Dumper`相当です。

```ruby
p irb(main):043:0> p key1: 'val1', key2: [1, 2, 3]
{:key1=>"val1", :key2=>[1, 2, 3]}
```

ここまで話した範囲のデータ型では`puts`と比べてあまりうまみが味わえないのですが、
より複雑なデータ構造を出力するときに役立ちます。

以降も`p`関数はよく使います。


## メソッド

Rubyでのメソッド定義は`def`文を使います。

`method.rb`
```ruby
def print_anything(s)
  p s
end

print_anything('hello')
print_anything 'world'
```

```ruby
$ ruby src/method.rb
"hello"
"world"
```

`p s`や`print_anything 'world'`を見ればわかるように、
メソッド呼び出し時に文法上明らかな場合はは`()`を省略できます。
Perlと同じですね。

メソッドについてはまだまだたくさん話題がありますが、それはまた別の機会に。


# オブジェクト指向プログラミング(OOP)

# ネタ出し

- Rubyは何でもオブジェクト
  - ネイティブ型なし
  - 「データ型」もネイティブ型でなくクラス

- OOPの中心的概念
  - カプセル化
    - protected, private
    - インスタンス変数
  - 継承
    - オーバーライド
      - オーバーライドがC++とかとは違うって話
        - 子クラスで同名の関数定義したら、引数が違っていても、親クラスの定義はなくなる
    - インスタンス変数の扱い
  - ポリモフィズム
    - duck typing (ポリモフィズムの1実装)
    - cf. オーバーロード C++

- クラスをより深める
  - クラス変数、関数

- 単純なクラスベース以外のOOP支援機構
  - mix-in
  - 特異メソッドの解説と用途(深ポイント)
    - http://blog.livedoor.jp/sasata299/archives/51497378.html

# まとめ

## まだやれてないこと

- classで残った大事なこと
